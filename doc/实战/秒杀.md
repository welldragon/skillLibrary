并发读、并发写
高性能
一致性
高可用

加载页面，定时上架，抢购，商品和库存判断，支付

# 架构原则

* 数据要尽量少
  * 减少请求体积（简化页面效果）
  * 减少响应体积（数据精简）
* 请求数要尽量少
  * css内联
  * 多个js合并
* 路径要尽量短
  * RPC服务合并部署，变成进程调用
* 依赖要尽量少
  * 依赖服务分级，做好隔离和熔断降级
* 不要有单点
  * 无状态

# 动静分离
* 静态数据（只包含商品信息）动态（包含用户信息）
* 不刷新整页面，部分刷新
* 离用户进（CDN，浏览器，nignx缓存）
* 减少请求体积（静态数据不发送cookies）
* 缓存（本地，前置hash，热点数据多份，CDN缓存和失效方案）

# 热点数据
* 热点操作（写）（CAP）
* 热点数据（读）
  * 静态热点数据（可以提前预测的）大数据分析，产品方式（定期，提前报名）
  * 动态热点数据：上游系统的热点访问记录实时分析
  * 处理
    * 优化（提前缓存）
    * 限制（一致性hash队列，不影响其他99%）
    * 隔离（中间间隔离，独立redis和mysql）

# 流量削峰
* 排队（限流）
* 答题（产品，防止作弊，延缓请求发出）提前推送CDN
* 分层过滤
  * CDN
  * 前台详情（不做强一致校验，商品状态判断，答题正确，是否结束）
  * 后台交易（强一致，库存不能未负）
  * DB

# 减库存
* 下单减（恶意下单）
* 付款减（付款没有库存失败）
* 下单预减，保留10分钟没付款就释放（恶意买家打标签，不扣库存）

秒杀用下单减（因为操作简单）

数据库限制库存不能小于0，不要读库存数量在update减1

简单的库存，用redis减库存

# plan B（高可用）
* 架构阶段
  * 异地容灾
  * 异步化
  * 分组隔离
  * 避免单点
* 编码阶段
  * 限流保护
  * 超时处理
  * 异步线程
  * 错误捕获
* 测试阶段
  * bate测试
  * 自动化对比测试
* 发布阶段
  * 分批发布
  * 多版本发布
* 运行阶段
  * 数据对账
  * 自动降级
  * 过载保护
  * 实时监控报警
* 故障发生
  * 快速恢复
  * 故障定位

秒杀重要的是
* 降级（基于业务的开关系统，流量大于一直值，详情页面就不现实优惠券，支付页面再显示）
* 限流（QPS，压测的80%）
* 拒绝服务（前置拒绝服务，nignx直接返回503）